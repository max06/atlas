# code: language=helm

{{- /*
================================================================================
MAIN LOGIC: CLUSTER AND DEPLOYMENT DISCOVERY
================================================================================

This template discovers all clusters in the deployment tree and assigns
deployments to them based on a hierarchical structure.

DIRECTORY STRUCTURE:
  deployments/
    apps/                           ← Global deployments (all clusters)
      global-app/
        deployment.yaml

    single-cluster/                 ← Standalone cluster (no group)
      apps/
        single-app/
          deployment.yaml

    group-name/                     ← Cluster group
      apps/                         ← Group-level deployments
        group-app/
          deployment.yaml

      cluster-a/                    ← Individual cluster in group
        apps/
          cluster-app/
            deployment.yaml

      cluster-b/                    ← Another cluster in same group
        apps/
          another-app/
            deployment.yaml

DEPLOYMENT ASSIGNMENT RULES:
1. Global deployments (deployments/apps/*) → assigned to ALL clusters
2. Group deployments (deployments/GROUP/apps/*) → assigned to all clusters in GROUP
3. Cluster deployments (deployments/[GROUP/]CLUSTER/apps/*) → assigned to that CLUSTER only

OUTPUT FORMAT:
  A flat list where each item contains:
  - cluster: "group-name/cluster-a" or "single-cluster"
  - deploymentName: "app-name"
  - path: "/absolute/path/to/deployment.yaml"
*/ -}}

{{- /* Lets make sure the passed working directory is set, exists and is absolute */ -}}
{{- if not (and (isAbs .Values.atlas.cwd) (isDir .Values.atlas.cwd)) -}}
  {{- fail "No valid cwd given" -}}
{{- end -}}
{{- $repoRoot := .Values.atlas.cwd -}}
{{- $cwd := exec "pwd" (list) -}}

# From template
{{ $repoRoot }}
{{ $cwd }}

{{- /*
STEP 1: DISCOVER ALL CLUSTERS
Find all directories with an "apps" subdirectory, which indicates either:
- A cluster (if it's a leaf node with no child clusters)
- A cluster group (if it has child clusters beneath it)
*/ -}}
{{- $clustersPattern := printf "%s/%s/**/apps" .Values.atlas.cwd .Values.atlas.deploymentDefinitions -}}

# DEBUG!
{{ $clustersPattern }}
{{ "" }}

{{- $rawClusters := include "glob" $clustersPattern | fromJson -}}

{{- /* Dictionary to store discovered leaf clusters (actual deployment targets) */ -}}
{{- /* Key: cluster path like "cyrannus/helios" or "single-cluster" */ -}}
{{- /* Value: empty list (placeholder, will be populated in step 2) */ -}}
{{- $clusters := dict -}}

{{- range $rawClusters -}}
  {{- $absolutePath := . -}}
  {{- $pathParts := $absolutePath | splitList "/" -}}

  {{- /*
  Find the index where the deploymentDefinitions directory appears in the path.
  Example path: "/workspaces/repo/clusters/cyrannus/helios/apps"
  Split parts: ["", "workspaces", "repo", "clusters", "cyrannus", "helios", "apps"]
  If deploymentDefinitions is "clusters", clustersIdx: 3
  */ -}}
  {{- $clustersIdx := -1 -}}
  {{- range $idx, $part := $pathParts -}}
    {{- if eq $part $.Values.atlas.deploymentDefinitions -}}
      {{- $clustersIdx = $idx -}}
    {{- end -}}
  {{- end -}}

  {{- /*
  Extract the cluster path between deploymentDefinitions and "apps".
  Example: ["", "workspaces", "repo", "clusters", "cyrannus", "helios", "apps"]
           → slice from index 4 to 6 → ["cyrannus", "helios"]
           → join with "/" → "cyrannus/helios"

  Note: We skip paths with only 2 parts after deploymentDefinitions (e.g., "clusters/apps")
        because that's the global apps directory, not a cluster.
  */ -}}
  {{- if and (ge $clustersIdx 0) (gt (sub (len $pathParts) $clustersIdx) 2) -}}
    {{- $clusterPath := slice $pathParts (add1 $clustersIdx) (sub (len $pathParts) 1) | join "/" -}}

    {{- /*
    Determine if this is a LEAF cluster (actual deployment target) or a GROUP.
    A cluster is a leaf if it has no child directories with "apps" subdirectories.

    Example:
    - "/workspaces/repo/clusters/cyrannus/helios/apps" is a LEAF (no children found)
    - "/workspaces/repo/clusters/cyrannus/apps" is a GROUP if pattern finds children
    */ -}}
    {{- $childPattern := printf "%s/%s/%s/*/apps" $.Values.atlas.cwd $.Values.atlas.deploymentDefinitions $clusterPath -}}
    {{- $hasChildren := include "glob" $childPattern | fromJson -}}
    {{- $isLeaf := eq (len $hasChildren) 0 -}}

    {{- /* Only add leaf clusters (actual deployment targets) to our dictionary */ -}}
    {{- if $isLeaf -}}
      {{- $_ := set $clusters $clusterPath (list) -}}
    {{- end -}}
  {{- end -}}
{{- end -}}

{{- /*
STEP 2: COLLECT DEPLOYMENTS FOR EACH CLUSTER
For each discovered cluster, gather all deployments from:
1. Global level (clusters/apps/*)
2. Group level (clusters/GROUP/apps/*) - if cluster is in a group
3. Cluster level (clusters/GROUP/CLUSTER/apps/* or clusters/CLUSTER/apps/*)
*/ -}}

{{- /* This will be our final output: a flat list of deployment assignments */ -}}
{{- $deploymentsList := list -}}

{{- /* Iterate through each discovered cluster in alphabetical order */ -}}
{{- range $cluster := keys $clusters | sortAlpha -}}
  {{- /* Temporary list to collect this cluster's deployments */ -}}
  {{- $clusterDeployments := list -}}

  {{- /*
  LEVEL 1: GLOBAL DEPLOYMENTS
  These are found in clusters/apps/* and apply to ALL clusters.
  Pattern: /absolute/path/clusters/apps/*/deployment.yaml
  */ -}}
  {{- $globalPattern := printf "%s/%s/apps/*/deployment.yaml" $.Values.atlas.cwd $.Values.atlas.deploymentDefinitions -}}
  {{- $rawDeployments := include "glob" $globalPattern | fromJson -}}

  {{- /*
  LEVEL 2: GROUP DEPLOYMENTS (if applicable)
  If this cluster is part of a group (e.g., "cyrannus/helios"),
  include deployments from the group level (e.g., "clusters/cyrannus/apps/*").

  The group path is the directory containing the cluster.
  Example: "cyrannus/helios" → dir → "cyrannus"

  If dir returns "." (no parent), this is a standalone cluster with no group.
  */ -}}
  {{- $groupPath := $cluster | dir -}}
  {{- if ne $groupPath "." -}}
    {{- $groupPattern := printf "%s/%s/%s/apps/*/deployment.yaml" $.Values.atlas.cwd $.Values.atlas.deploymentDefinitions $groupPath -}}
    {{- $groupDeployments := include "glob" $groupPattern | fromJson -}}
    {{- /* Append group deployments to our collection */ -}}
    {{- $rawDeployments = concat $rawDeployments $groupDeployments -}}
  {{- end -}}

  {{- /*
  LEVEL 3: CLUSTER-SPECIFIC DEPLOYMENTS
  These are unique to this specific cluster.
  Pattern: /absolute/path/clusters/GROUP/CLUSTER/apps/*/deployment.yaml
       or: /absolute/path/clusters/CLUSTER/apps/*/deployment.yaml (for standalone clusters)
  */ -}}
  {{- $clusterPattern := printf "%s/%s/%s/apps/*/deployment.yaml" $.Values.atlas.cwd $.Values.atlas.deploymentDefinitions $cluster -}}
  {{- $specificDeployments := include "glob" $clusterPattern | fromJson -}}
  {{- $rawDeployments = concat $rawDeployments $specificDeployments -}}

  {{- /*
  PROCESS DEPLOYMENT PATHS
  Convert each deployment path into a structured object with:
  - deploymentName: extracted from the directory name
  - path: absolute path to the deployment.yaml file
  */ -}}
  {{- range $rawDeployments -}}
    {{- /*
    Extract deployment name from path.
    Example: "/workspaces/repo/clusters/apps/global-sample/deployment.yaml"
             → dir → "/workspaces/repo/clusters/apps/global-sample"
             → base → "global-sample"
    */ -}}
    {{- $deploymentName := . | dir | base -}}

    {{- /*
    Path is already absolute from the glob function, so we can use it directly
    */ -}}
    {{- $fullPath := . -}}

    {{- /* Add this deployment to the cluster's collection */ -}}
    {{- $clusterDeployments = append $clusterDeployments (dict "deploymentName" $deploymentName "path" $fullPath) -}}
  {{- end -}}

  {{- /*
  FLATTEN: Add cluster name to each deployment and append to final list.
  Instead of { cluster1: [dep1, dep2], cluster2: [dep3, dep4] }
  We create: [
    {cluster: cluster1, deploymentName: dep1, path: ...},
    {cluster: cluster1, deploymentName: dep2, path: ...},
    {cluster: cluster2, deploymentName: dep3, path: ...},
    ...
  ]
  */ -}}
  {{- range $clusterDeployments -}}
    {{- /* Merge the cluster name into the deployment dict */ -}}
    {{- $deploymentsList = append $deploymentsList (merge . (dict "cluster" $cluster)) -}}
  {{- end -}}
{{- end -}}


{{- /*
================================================================================
OUTPUT
================================================================================
Generate the final YAML structure with the flat list of deployments.
*/ -}}
environments:
  default:
    values:
      - deployments: {{ $deploymentsList | toYaml | nindent 10 }}

---

# Loading all deployments

helmfiles:
{{ range $deployment := .Values.deployments }}
  - path: helmfile.single.yaml.gotmpl
    values:
      - {{ $deployment | toYaml | nindent 8 }}
{{- end -}}
