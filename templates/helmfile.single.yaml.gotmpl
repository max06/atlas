# Rendering a single deployment based on the contents of its deployment.yaml file.
# This template assembles and merges values from various sources (global, group, cluster, deployment),
# handles SOPS-encrypted files by decrypting individual keys, and processes regular YAML or Go template files.
# It then uses the merged values to render the deployment configuration and generate helmfile entries for each app instance.

{{- $debug := include "debugEnabled" . | trim | eq "true" }}

# Prepare base variables used throughout the template.
{{- $basePath := printf "%s/%s" .Values.atlas.cwd .Values.atlas.deploymentDefinitions }}
{{- $hasGroup := contains "/" .Values.atlas.deployment.cluster }}

{{- if $debug }}
# DEBUG: Path to deployment definitions: {{ $basePath }}
# DEBUG: Cluster is part of a group: {{ $hasGroup }}
# DEBUG: Current context:
{{- range $line := . | toYaml | indent 2 | splitList "\n" }}
# {{- $line }}
{{- end -}}
{{- end }}

# Assemble the list of value source files in priority order:
# 1. Global values (applied to all deployments).
# 2. Group values (if the cluster belongs to a group).
# 3. Cluster-specific values.
# 4. Deployment-specific values (shared across all instances in this deployment).
# Note: Instance-specific values are loaded later in the process.
# Files can be SOPS-encrypted (.sops.yaml), plain YAML (.yaml), or Go templates (.yaml.gotmpl).

{{- $sources := list
  (printf "%s/global.values.sops.yaml" $basePath)
  (printf "%s/global.values.yaml" $basePath)
  (printf "%s/global.values.yaml.gotmpl" $basePath)
}}

{{- if $hasGroup }}
{{- $sources = concat $sources (list
    (printf "%s/%s/group.values.sops.yaml" $basePath (dir .Values.atlas.deployment.cluster))
    (printf "%s/%s/group.values.yaml" $basePath (dir .Values.atlas.deployment.cluster))
    (printf "%s/%s/group.values.yaml.gotmpl" $basePath (dir .Values.atlas.deployment.cluster))
  )
}}
{{- end -}}

{{- $sources = concat $sources (list
    (printf "%s/%s/cluster.values.sops.yaml" $basePath .Values.atlas.deployment.cluster)
    (printf "%s/%s/cluster.values.yaml" $basePath .Values.atlas.deployment.cluster)
    (printf "%s/%s/cluster.values.yaml.gotmpl" $basePath .Values.atlas.deployment.cluster)
  )
}}

{{- $sources = concat $sources (list
    (printf "%s/values.sops.yaml" (dir .Values.atlas.deployment.path))
    (printf "%s/values.yaml" (dir .Values.atlas.deployment.path))
    (printf "%s/values.yaml.gotmpl" (dir .Values.atlas.deployment.path))
  )
}}

{{- if $debug }}
# DEBUG: Files to check:
{{- range $entry := $sources }}
# - {{- $entry }}
{{- end }}
{{- end }}

# Initialize a dictionary to store merged loaded values.
{{- $loadedValues := dict }}

# Process each source file:
# - Skip if the file does not exist.
# - For SOPS files: Read as YAML, skip the 'sops' key, decrypt each remaining key-value pair individually.
# - For regular files (.yaml or .yaml.gotmpl): Read the content, render as Go template using current $loadedValues,
#   parse as YAML, and merge overwrite into $loadedValues.
# Note: Merging is done in order, so later files override earlier ones.
{{- range $source := $sources }}
  {{- if $debug }}
  # DEBUG: Testing file: {{ $source }}
  {{- end }}
  {{- if isFile $source }}
    {{- if $debug }}
    # DEBUG: File found: {{ $source }}
    {{- end }}
    {{- if contains "sops.yaml" $source }}
      {{- if $debug }}
      # DEBUG: File is SOPS-encrypted, decoding...
      {{- end }}
      {{- $content := readFile $source | fromYaml }}
      {{- range $key, $value := (omit $content "sops") }}
        {{- $decryptedValue := fetchSecretValue (printf "ref+sops://%s#%s" $source $key) }}
        {{- if $debug }}
        # DEBUG: Decrypted key '{{ $key }}' with value: {{ $decryptedValue }}
        {{- end }}
        {{- $_ := set $loadedValues $key $decryptedValue }}
      {{- end }}
    {{- else }}
      {{- if $debug }}
      # DEBUG: Regular file, reading and rendering as template, then merging...
      {{- end }}
      {{- $renderedContent := $loadedValues | tpl (readFile $source) | fromYaml }}
      {{- if $debug }}
      # DEBUG: Rendered values: {{ $renderedContent | toJson }}
      {{- end }}
      {{- $loadedValues = mergeOverwrite $loadedValues $renderedContent }}
    {{- end }}
    {{- if $debug }}
    # DEBUG: Finished processing {{ $source }}. Current merged values: {{ $loadedValues | toJson }}
    {{- end }}
  {{- end }}
{{- end }}

# Load and render the deployment.yaml file using the merged $loadedValues.
# This replaces any template strings in the deployment config.
{{- if isFile .Values.atlas.deployment.path }}
  {{- $deployment := $loadedValues | tpl (readFile .Values.atlas.deployment.path) | fromYaml }}

# Output the helmfiles section as YAML.
# For each app instance in the deployment:
# - Merge instance-specific values with the shared $loadedValues.
# - Generate a helmfile entry pointing to the app's template, injecting atlas.deployment and atlas.instance contexts.
helmfiles:
  {{- range $instance := $deployment.apps }}
  {{- $_ := set $instance "values" (mergeOverwrite ($instance | get "values" dict) $loadedValues) }}
  - path: {{ $.Values.atlas.cwd }}/{{ $.Values.atlas.appTemplates }}/{{ $instance.template }}/helmfile.yaml.gotmpl
    values:
      - atlas:
          deployment: {{ $.Values.atlas.deployment | toYaml | nindent 12 }}
          instance: {{ $instance | toYaml | nindent 12 }}
      - {{ $instance.values | toYaml | nindent 8 }}
  {{- end }}
{{- else }}
{{- fail (printf "Deployment file not found: %s" .Values.atlas.deployment.path) }}
{{- end }}
